# javascript垃圾回收

## 垃圾回收&GC算法

### JavaScript 自动垃圾收集机制

垃圾回收又称为 GC(Garbage Collecation)。编写 JavaScript 程序时，开发者不需要手工跟踪内存的使用情况，只要按照标准写 JavaScript 代码，JavaScript 程序运行所需内存的分配以及无用内存的回收完全是自动管理。JavaScript 中自动垃圾回收机制的原理为:

* 找出那些不再使用的变量，然后释放其占用的内存。
* 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。

### 引用计数算法

引用计数(reference counting) 是一种垃圾收集策略。引用计数的本质是——跟踪记录每个值被引用的次数。执行机制如下：

* 核心思想: 设置引用数，判断当前引用数是否为0
* 引用计数器
* 引用关系改变时修改引用数字
* 引用数字为0时立即回收

**优点：**

* 发现垃圾立即回收，
* 最大限度减少程序暂停

**缺点：**

* 无法回收循环引用的对象
* 时间开销大

### 标记清除算法

标记清除(mark-and-sweep) 是 JavaScript 中最常用的垃圾回收方式。其执行机制如下：

* 核心思想：分标记和清除两个阶段完成
* 遍历所有对象找标记活动对象
* 遍历所有对象清除没有标记的对象
* 回收相应的空间

**优点:**

* 可以释放无法访问的循环引用对象
* 必要时才回收(内存不足时)

**缺点:**

* 回收时，应用需要挂起，也就是stop the world。
* 标记和清除的效率不高，尤其是要扫描的对象比较多的时候
* 会造成内存碎片化(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)

### 标记整理算法

* 分为标记和整理两个阶段
* 标记阶段的操作和标记清除一致
* 清除阶段会先执行整理，移动对象的位置

**优点:**

* 减少碎片化空间

**缺点:**

* 不会立即回收垃圾对象
* 移动对象需要消耗一定的时间，回收效率慢

## V8垃圾回收

在V8中，将内存分为了新生代（new space）和老生代（old space）。它们特点如下：

* 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
* 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

默认设置下，64位系统的老生代大小为1400M，32位系统为700M。
对于新生代，它由两个 reserved_semispace_size 组成。每个reserved_semispace_size 的大小在不同位数的机器上大小不同。默认设置下，在64位与32位的系统下分别为16MB和8MB。

**回收过程**

1. 从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。
2. 检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。
3. 若对象不存活，则释放不存活对象的空间。
4. 完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。

**对象晋升**

对象晋升的条件有两个：

1. 在垃圾回收的过程中，如果发现某个对象之前被清理过，那么会将其晋升到老生代内存空间中
2. 在 From 空间和 To 空间进行反转的过程中，如果 To 空间中的使用量已经超过了 25%，那么就将 From 中的对象直接晋升到老生代内存空间中

**增量标记**

GC触发标记清除回收时，程序会暂停，标记清除算法一口气标记全部活动对象，相对耗时太久。
增量标记将标记过程根据直接可达对象和间接可达对象(例如obj.foo和obj.foo.bar)，将一整个过程拆分成多个小过程，每个过程指标记一层可达对象，标记完继续执行程序，然后再执行下个标记小过程。
这样对用户来说，程序执行更连贯。