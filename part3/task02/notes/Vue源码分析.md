# Vue.js 源码分析（响应式、虚拟 DOM、模板编译和组件化）



## 准备工作

#### Vue源码获取：

源码地址：[https://github.com/vuejs/vue](https://github.com/vuejs/vue)

#### 源码部分目录结构：

```
└── vue-dev ································· project root
   ├─ src ············································ source folder
   │  ├─ compiler ······································ 编译相关
   │  ├─ core ··········································· Vue 核心库
   │  ├─ platforms ···································· 平台相关代码
   │  ├─ server ········································ SSR,，服务端渲染
   │  ├─ sfc ············································ Vue编译为js对象文件
   │  └─ shared ······································· 公共代码
   ├─ .gitignore ····································· git ignore file
   ├─ README.md ······································ repo readme
   ├─ package.json ··································· package file
   └─ yarn.lock ······································ yarn lock file
```

#### 了解Flow：

- 官网：https://flow.org/ 
- JavaScript 的静态类型检查器 
- Flow 的静态类型检查错误是通过静态类型推断实现的

```javascript
/* @flow */
function square(n: number): number {
	return n * n;
}
square("2"); // Error!
```

#### 调试设置：

**安装依赖：** 

`npm i`

**打包工具 Rollup:**

- Vue.js 源码的打包工具使用的是 Rollup，比 Webpack 轻量 
- Webpack 把所有文件当做模块，Rollup 只处理 js 文件更适合在 Vue.js 这样的库中使用 
- Rollup 打包不会生成冗余的代码

**Vue的不同构建版本：**

官方文档：[https://cn.vuejs.org/v2/guide/installation.html](https://cn.vuejs.org/v2/guide/installation.html)

|                                                      | UMD                | CommonJS              | ES Module (基于构建工具使用) | ES Module (直接用于浏览器) |
| :--------------------------------------------------- | :----------------- | :-------------------- | :--------------------------- | -------------------------- |
| Runtime-only[完整版]                                 | vue.js             | vue.common.js         | vue.esm.js                   | vue.esm.browser.js         |
| Runtime-only[只包含运行时版]                         | vue.runtime.js     | vue.runtime.common.js | vue.runtime.esm.js           | -                          |
| Full (production)[完整版 (生产环境)]                 | vue.min.js         | -                     | -                            | vue.esm.browser.min.js     |
| Runtime-only (production)[只包含运行时版 (生产环境)] | vue.runtime.min.js | -                     |                              |                            |



## Vue响应式原理

**入口文件：** vue/src/platforms/web/



## 虚拟DOM

### 不用 key：

- **就地复用节点**。在比较新旧两个节点是否是同一个节点的过程中会判断成新旧两个节点是同一个节点，因为 `a.key` 和 `b.key` 都是 undefined。所以不会重新创建节点和删除节点，只会在节点的属性层面上进行比较和更新。所以可能在某种程度上（创建和删除节点方面）会有渲染性能上的提升；
- **无法维持组件的状态**。由于就地复用节点的关系，可能在维持组件状态方面会导致不可预知的错误，比如无法维持改组件的动画效果、开关等状态；
- **也有可能会带来性能下降**。因为是直接就地复用节点，如果修改的组件，需要复用的很多节点，顺序又和原来的完全不同的话，那么创建和删除的节点数量就会比带 key 的时候增加很多，性能就会有所下降；

### 用 key：

- **维持组件的状态，保证组件的复用**。因为有 key 唯一标识了组件，不会在每次比较新旧两个节点是否是同一个节点的时候直接判断为同一个节点，而是会继续在接下来的节点中找到 key 相同的节点去比较，能找到相同的 key 的话就复用节点，不能找到的话就增加或者删除节点。
- **查找性能上的提升**。有 key 的时候，会生成 hash，这样在查找的时候就是 hash 查找了，基本上就是 O(1) 的复杂度。
- **节点复用带来的性能提升**。因为有 key 唯一标识了组件，所以会尽可能多的对组件进行复用（尽管组件顺序不同），那么创建和删除节点数量就会变少，这方面的消耗就会下降，带来性能的提升。

## 模板编译和组件化

### 模板编译



### 组件化